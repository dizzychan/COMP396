
import backtrader as bt
import datetime


# -----------------------------------------------------------------------------
# 1. 基础指标
# -----------------------------------------------------------------------------

class AbsPctChange(bt.Indicator):
    lines = ("abspct",)
    params = (('period', 1),)

    def __init__(self):
        prev = self.data0(-1)
        self.l.abspct = bt.If(prev != 0.0, abs(self.data0 / prev - 1.0), 0.0)


class BBandWidth(bt.Indicator):
    lines = ('width',)
    params = (('period', 20), ('devfactor', 2.0),)

    def __init__(self):
        bb = bt.ind.BollingerBands(self.data, period=self.p.period, devfactor=self.p.devfactor)
        self.lines.width = bt.If(bb.mid != 0, (bb.top - bb.bot) / bb.mid, 0.0)




class EliteSniperStrategy(bt.Strategy):
    params = dict(
        printlog=True,

        # --- [风控] ---
        risk_total_budget=20000.0,
        risk_per_trade_cap=0.015,
        risk_atr_period=14,

        # [出场] 稍微降低止盈预期，提高胜率
        take_profit_mult=3.0,  # [V6] 3.5 -> 3.0 (更容易落袋)
        breakeven_trigger_mult=0.8,  # [V6] 1.0 -> 0.8 (更快保本)

        # --- [特征识别] 门槛大幅降低 ---
        adx_period=14,
        adx_threshold=20,  # [V6] 30 -> 20 (弱趋势也做)
        bbw_period=20,
        bbw_upper_mult=1.4,  # [V6] 1.5 -> 1.4 (更容易判定为震荡)

        #  Trend 
        t_ma_filter=200,
        t_fast=20, t_slow=60,
        t_pullback_atr=0.3,  # [V6] 0.6 -> 0.3 (浅回调就买)
        t_validity=3,

        # Bollinger 
        b_period=20,
        b_dev=2.4,  # [V6] 2.5 -> 2.4 (更容易触碰)
        b_rsi_buy=35,  # [V6] 30 -> 35
        b_rsi_sell=65,
        b_limit_buffer_atr=0.1,  # [V6] 挂单更激进
        b_validity=2,

        # Momentum 
        m_fast=12, m_slow=26, m_sig=9,
        m_breakout_atr_mult=0.2,  # [V6] 追涨更紧
        m_trend_filter=20,  # [V6 核心] 60 -> 20 (只要在中轨之上就敢做)
        m_vol_mult=1.1,  # [V6 核心] 1.5 -> 1.1 (微放量即可)
        m_validity=1,

        # 止损设置 
        stop_mult_trend=2.0,  # [V6] 2.5 -> 2.0
        stop_mult_range=1.5,
        max_units=100000,
        cooldown=2,  # [V6] 5 -> 2 (快速重返战场)
    )

    def __init__(self):
        # 状态管理
        self.order_pending = {}
        self.trade_source = {}
        self.cooldown_timer = {}
        self.risk_alloc = {}
        self.trade_entry_price = {}
        self.trade_stop_price = {}
        self.is_breakeven_set = {}
        self.inds = {}

        for d in self.datas:
            self.order_pending[d] = False
            self.trade_source[d] = None
            self.cooldown_timer[d] = 0
            self.trade_entry_price[d] = None
            self.trade_stop_price[d] = None
            self.is_breakeven_set[d] = False
            self.inds[d] = {}

            # --- 指标 ---
            self.inds[d]['adx'] = bt.ind.ADX(d, period=self.p.adx_period)
            self.inds[d]['bbw'] = BBandWidth(d, period=self.p.bbw_period)
            self.inds[d]['avg_bbw'] = bt.ind.SMA(self.inds[d]['bbw'], period=50)
            self.inds[d]['atr'] = bt.ind.ATR(d, period=self.p.risk_atr_period)
            self.inds[d]['vol_proxy'] = bt.ind.SMA(AbsPctChange(d.close), period=20)
            self.inds[d]['vol'] = d.volume
            self.inds[d]['vol_ma'] = bt.ind.SMA(d.volume, period=20)

            # [滤网]
            self.inds[d]['ma_200'] = bt.ind.SMA(d.close, period=self.p.t_ma_filter)
            self.inds[d]['ma_20'] = bt.ind.SMA(d.close, period=self.p.m_trend_filter)  # V6 改为 MA20

            # 战术指标
            sma_f = bt.ind.SMA(d.close, period=self.p.t_fast)
            sma_s = bt.ind.SMA(d.close, period=self.p.t_slow)
            self.inds[d]['t_cross'] = bt.ind.CrossOver(sma_f, sma_s)

            self.inds[d]['bb'] = bt.ind.BollingerBands(d.close, period=self.p.b_period, devfactor=self.p.b_dev)
            self.inds[d]['rsi'] = bt.ind.RSI(d.close, period=14)

            self.inds[d]['macd'] = bt.ind.MACD(d.close)
            self.inds[d]['m_cross'] = bt.ind.CrossOver(self.inds[d]['macd'].macd, self.inds[d]['macd'].signal)

    # -------------------------------------------------------------------------
    # 辅助逻辑
    # -------------------------------------------------------------------------

    def log_data(self, d, txt):
        if self.p.printlog:
            try:
                dt = d.datetime.date(0)
                d_name = getattr(d, '_name', 'Data')
                print(f"{dt} [{d._name}] {txt}")
            except:
                pass

    def _determine_regime(self, d):
        adx = self.inds[d]['adx'][0]
        bbw = self.inds[d]['bbw'][0]
        avg_bbw = self.inds[d]['avg_bbw'][0]
        close = d.close[0]
        ma_200 = self.inds[d]['ma_200'][0]

        # 门槛降低
        if adx > self.p.adx_threshold:
            if close > ma_200:
                return 'TREND'
            return None

        elif bbw > (avg_bbw * self.p.bbw_upper_mult):
            return 'VOLATILE'

        elif bbw < (avg_bbw * 0.8):
            return 'SQUEEZE'

        return None

    def _calc_risk_budgets(self):
        raw_weights = {}
        total_inv_vol = 0.0
        for d in self.datas:
            vol = self.inds[d]['vol_proxy'][0]
            if vol <= 0: continue
            w = 1.0 / max(1e-8, vol)
            raw_weights[d] = w
            total_inv_vol += w
        self.risk_alloc = {}
        if total_inv_vol > 0:
            for d, w in raw_weights.items():
                self.risk_alloc[d] = (w / total_inv_vol) * self.p.risk_total_budget

    def _get_size(self, d, stop_mult):
        budget = self.risk_alloc.get(d, 0.0)
        atr = self.inds[d]['atr'][0]
        if budget <= 0 or atr <= 0: return 0
        max_risk = self.broker.getvalue() * self.p.risk_per_trade_cap
        budget = min(budget, max_risk)
        stop_dist = atr * stop_mult
        if stop_dist == 0: return 0
        units = int(budget // stop_dist)
        return min(units, self.p.max_units)

    # -------------------------------------------------------------------------
    # 
    # -------------------------------------------------------------------------

    def _run_t_strategy(self, d):
        cross = self.inds[d]['t_cross'][0]
        if cross <= 0: return

        size = self._get_size(d, self.p.stop_mult_trend)
        if size == 0: return

        valid = d.datetime.date(0) + datetime.timedelta(days=self.p.t_validity)
        atr = self.inds[d]['atr'][0]

        # 0.3 ATR 浅回调
        price = d.close[0] - (atr * self.p.t_pullback_atr)

        self.buy(data=d, size=size, price=price, exectype=bt.Order.Limit, valid=valid)
        self.log_data(d, f"[TREND] Active Entry. Limit BUY @ {price:.2f}")

        self.trade_source[d] = 'T'
        self.order_pending[d] = True

    def _run_b_strategy(self, d):
        bb = self.inds[d]['bb']
        rsi = self.inds[d]['rsi'][0]
        close = d.close[0]
        atr = self.inds[d]['atr'][0]

        # [V6] 门槛降低：Dev 2.4, RSI 35
        if close < bb.bot[0] and rsi < self.p.b_rsi_buy:
            size = self._get_size(d, self.p.stop_mult_range)
            if size == 0: return

            # [V6] 挂单就在下轨附近
            price = bb.bot[0] - (atr * self.p.b_limit_buffer_atr)
            valid = d.datetime.date(0) + datetime.timedelta(days=self.p.b_validity)

            self.buy(data=d, size=size, price=price, exectype=bt.Order.Limit, valid=valid)
            self.log_data(d, f"[VOLATILE] Dip Buy. Limit @ {price:.2f}")
            self.trade_source[d] = 'B'
            self.order_pending[d] = True

    def _run_m_strategy(self, d):
        cross = self.inds[d]['m_cross'][0]
        # [V6] 1.1倍成交量 (微放量)
        vol_spike = self.inds[d]['vol'][0] > (self.inds[d]['vol_ma'][0] * self.p.m_vol_mult)
        # [V6] 只要在 MA20 之上就敢做
        trend_ok = d.close[0] > self.inds[d]['ma_20'][0]

        if cross > 0 and vol_spike and trend_ok:
            size = self._get_size(d, self.p.stop_mult_trend)
            if size == 0: return

            valid = d.datetime.date(0) + datetime.timedelta(days=self.p.m_validity)
            atr = self.inds[d]['atr'][0]

            self.buy(data=d, size=size, exectype=bt.Order.Market)
            limit_px = d.close[0] - (atr * self.p.m_breakout_atr_mult)
            self.buy(data=d, size=size // 2, price=limit_px, exectype=bt.Order.Limit, valid=valid)
            self.log_data(d, f"[SQUEEZE] Active Breakout. BUY (Mkt + Lim)")

            self.trade_source[d] = 'M'
            self.order_pending[d] = True

    # -------------------------------------------------------------------------
    # 出场与风控
    # -------------------------------------------------------------------------

    def _check_exits(self, d, pos):
        source = self.trade_source[d]
        close = d.close[0]
        atr = self.inds[d]['atr'][0]
        entry = self.trade_entry_price[d]

        if entry is None or atr <= 0: return False

        # 1. 动态止盈
        profit_dist = close - entry if pos.size > 0 else entry - close
        if profit_dist > (atr * self.p.take_profit_mult):
            self.close(data=d)
            self.log_data(d, f"[EXIT] Quick Target Hit (+{self.p.take_profit_mult} ATR).")
            return True

        # 2. 保本逻辑 (0.8 ATR 快速保本)
        if not self.is_breakeven_set[d]:
            if profit_dist > (atr * self.p.breakeven_trigger_mult):
                self.trade_stop_price[d] = entry
                self.is_breakeven_set[d] = True
                self.log_data(d, "[RISK] Quick Breakeven Locked.")

        # 3. B策略中轨出场
        if source == 'B':
            mid = self.inds[d]['bb'].mid[0]
            if (pos.size > 0 and close >= mid):
                self.close(data=d)
                self.log_data(d, "[EXIT] B-Strategy Mid-Band.")
                return True

        # 4. 止损
        stop_price = self.trade_stop_price[d]
        if stop_price is None:
            mult = self.p.stop_mult_range if source == 'B' else self.p.stop_mult_trend
            if pos.size > 0:
                self.trade_stop_price[d] = entry - (atr * mult)
            else:
                self.trade_stop_price[d] = entry + (atr * mult)
            stop_price = self.trade_stop_price[d]

        if pos.size > 0:
            if close < stop_price:
                self.close(data=d)
                self.cooldown_timer[d] = self.p.cooldown
                self.log_data(d, f"[EXIT] Stop Loss.")
                return True
        return False

    def next(self):
        self._calc_risk_budgets()
        for d in self.datas:
            if self.cooldown_timer[d] > 0:
                self.cooldown_timer[d] -= 1
                continue
            if self.order_pending[d]:
                continue
            pos = self.getposition(d)
            if pos.size != 0:
                self._check_exits(d, pos)
                continue

            regime = self._determine_regime(d)
            if regime == 'TREND':
                self._run_t_strategy(d)
            elif regime == 'VOLATILE':
                self._run_b_strategy(d)
            elif regime == 'SQUEEZE':
                self._run_m_strategy(d)

    def notify_order(self, order):
        d = order.data
        if order.status in [order.Submitted, order.Accepted]: return
        if order.status in [order.Completed, order.Canceled, order.Margin, order.Rejected, order.Expired]:
            self.order_pending[d] = False
        if order.status == order.Completed:
            action = "BUY" if order.isbuy() else "SELL"
            price = order.executed.price
            self.log_data(d, f"{action} EXECUTED @ {price:.2f}")
            if self.getposition(d).size != 0:
                self.trade_entry_price[d] = price
                self.trade_stop_price[d] = None
                self.is_breakeven_set[d] = False
            else:
                self.trade_entry_price[d] = None
                self.trade_stop_price[d] = None
                self.is_breakeven_set[d] = False
                self.trade_source[d] = None
