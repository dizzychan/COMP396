import backtrader as bt
import math


# ============================================================
# 1. Indicators (基础指标)
# ============================================================

class AbsPctChange(bt.Indicator):
    lines = ("abspct",)

    def __init__(self):
        prev = self.data0(-1)
        self.l.abspct = bt.If(prev != 0.0, abs(self.data0 / prev - 1.0), 0.0)


class BBandWidth(bt.Indicator):
    """ 计算布林带宽度，用于判断波动率 """
    lines = ('width',)
    params = (('period', 20), ('devfactor', 2.0),)

    def __init__(self):
        bb = bt.ind.BollingerBands(self.data, period=self.p.period, devfactor=self.p.devfactor)
        self.lines.width = bt.If(bb.mid != 0, (bb.top - bb.bot) / bb.mid, 0.0)


# ============================================================
# 2. Strategy Class
# ============================================================

class TeamStrategy(bt.Strategy):
    params = dict(
        printlog=True,

        # --- 资金管理 ---
        total_equity=1_000_000.0,
        target_volatility=0.035,  # 3.5% 风险敞口
        max_units=1_000_000,
        invvol_lookback=20,

        # --- 特征识别参数 (The Brain) ---
        adx_period=14,
        adx_threshold=25,  # 趋势/震荡的分界线
        bbw_period=20,  # 用来判断波动率高低

        # --- T策略 (Trend - 强趋势专用) ---
        t_fast=10, t_slow=30,
        t_limit_offset=0.002,  # 趋势回调买入
        t_validity=1,

        # --- B策略 (Bollinger - 宽幅震荡专用) ---
        b_period=20, b_dev=2.0,
        b_rsi_period=14, b_rsi_buy=35, b_rsi_sell=65,
        b_limit_buffer=0.1,  # 深坑接飞刀

        # --- M策略 (Momentum - 挤压突破专用) ---
        m_fast=12, m_slow=26, m_sig=9,
        m_atr_mult=0.3,  # 突破加仓

        # --- 风控参数 ---
        atr_period=14,
        stop_loss_trend=3.5,  # 趋势模式宽止损
        stop_loss_range=1.5,  # 震荡模式窄止损
        cooldown=3,
    )

    def __init__(self):
        self.inds = {}
        self.orders = {}
        self.trade_source = {}  # 记录这笔交易是由谁(T/M/B)发起的
        self.cooldown_timer = {}

        for d in self.datas:
            self.inds[d] = {}
            self.orders[d] = []
            self.trade_source[d] = None
            self.cooldown_timer[d] = 0

            # --- 1. 特征指标 (指挥官) ---
            self.inds[d]['adx'] = bt.ind.ADX(d, period=self.p.adx_period)
            self.inds[d]['bbw'] = BBandWidth(d, period=self.p.bbw_period)
            # 计算 BBW 的移动平均，用于判断当前波动率是高还是低
            self.inds[d]['avg_bbw'] = bt.ind.SMA(self.inds[d]['bbw'], period=50)

            # --- 2. 资金/风控指标 ---
            self.inds[d]['atr'] = bt.ind.ATR(d, period=self.p.atr_period)
            self.inds[d]['vol_calc'] = bt.ind.SMA(AbsPctChange(d.close), period=self.p.invvol_lookback)

            # --- 3. 战术指标 (T/M/B) ---
            # T: 均线
            self.inds[d]['sma_f'] = bt.ind.SMA(d.close, period=self.p.t_fast)
            self.inds[d]['sma_s'] = bt.ind.SMA(d.close, period=self.p.t_slow)
            self.inds[d]['t_cross'] = bt.ind.CrossOver(self.inds[d]['sma_f'], self.inds[d]['sma_s'])

            # B: 布林+RSI
            self.inds[d]['bb'] = bt.ind.BollingerBands(d.close, period=self.p.b_period, devfactor=self.p.b_dev)
            self.inds[d]['rsi'] = bt.ind.RSI(d.close, period=self.p.b_rsi_period)

            # M: MACD
            self.inds[d]['macd'] = bt.ind.MACD(d.close, period_me1=self.p.m_fast, period_me2=self.p.m_slow,
                                               period_signal=self.p.m_sig)
            self.inds[d]['m_cross'] = bt.ind.CrossOver(self.inds[d]['macd'].macd, self.inds[d]['macd'].signal)

            # 状态锚点
            self.inds[d]['highest'] = None
            self.inds[d]['lowest'] = None

    def log(self, txt, dt=None):
        if self.p.printlog:
            dt = dt or self.datas[0].datetime.date(0)
            print(f"{dt} {txt}")

    # --- 核心：特征识别与指挥 (Feature Logic) ---
    def determine_regime(self, d):
        adx = self.inds[d]['adx'][0]
        bbw = self.inds[d]['bbw'][0]
        avg_bbw = self.inds[d]['avg_bbw'][0]

        # 1. 强趋势体制 (Trend Regime)
        if adx > self.p.adx_threshold:
            return 'TREND'

        # 2. 震荡体制 (Range Regime) - 波动率高于平均
        elif bbw > avg_bbw:
            return 'VOLATILE'

        # 3. 挤压/突破体制 (Squeeze Regime) - 波动率低，酝酿突破
        else:
            return 'SQUEEZE'

    def get_size(self, d):
        vol = self.inds[d]['vol_calc'][0]
        if vol <= 0: return 0
        risk_alloc = self.p.total_equity / len(self.datas) * self.p.target_volatility
        size = int(risk_alloc / vol / d.close[0])
        return min(size, self.p.max_units)

    def check_exit(self, d, pos_size):
        if pos_size == 0:
            self.inds[d]['highest'] = None
            self.inds[d]['lowest'] = None
            self.trade_source[d] = None
            return False

        px = d.close[0]
        atr = self.inds[d]['atr'][0]
        source = self.trade_source[d]

        # 动态止损逻辑：
        # 如果是 B (震荡) 进场的，用窄止损 (1.5)
        # 如果是 T/M (趋势/动量) 进场的，用宽止损 (3.5)
        sl_mult = self.p.stop_loss_range if source == 'B' else self.p.stop_loss_trend

        exit_sig = False
        if pos_size > 0:
            self.inds[d]['highest'] = max(self.inds[d]['highest'] or px, px)
            stop = self.inds[d]['highest'] - (atr * sl_mult)
            if px < stop: exit_sig = True
        else:
            self.inds[d]['lowest'] = min(self.inds[d]['lowest'] or px, px)
            stop = self.inds[d]['lowest'] + (atr * sl_mult)
            if px > stop: exit_sig = True

        if exit_sig:
            self.close(data=d)
            self.cooldown_timer[d] = self.p.cooldown
            self.log(f"[{d._name}] STOP LOSS ({source}). Cooldown activated.")
            return True
        return False

    def next(self):
        for d in self.datas:
            # 1. 冷却与订单检查
            if self.cooldown_timer[d] > 0:
                self.cooldown_timer[d] -= 1
                continue
            if len(self.orders[d]) > 0:
                continue

            pos = self.getposition(d)
            if self.check_exit(d, pos.size): continue

            # ========================================
            # 策略调度层 (Commander Layer)
            # ========================================

            # 只有空仓时才做开仓决策
            if pos.size == 0:
                base_size = self.get_size(d)
                if base_size == 0: continue

                # 获取当前市场特征
                regime = self.determine_regime(d)

                # --- 场景 1: 强趋势 (派 T 部队) ---
                if regime == 'TREND':
                    if self.inds[d]['t_cross'][0] > 0:  # 金叉
                        limit_price = d.close[0] * (1.0 - self.p.t_limit_offset)
                        o = self.buy(data=d, size=base_size, price=limit_price, exectype=bt.Order.Limit,
                                     valid=self.p.t_validity)
                        self.orders[d].append(o)
                        self.trade_source[d] = 'T'
                        self.log(f"[{d._name}] [TREND MODE] T-Strategy Buy Limit @ {limit_price:.2f}")

                    elif self.inds[d]['t_cross'][0] < 0:  # 死叉
                        limit_price = d.close[0] * (1.0 + self.p.t_limit_offset)
                        o = self.sell(data=d, size=base_size, price=limit_price, exectype=bt.Order.Limit,
                                      valid=self.p.t_validity)
                        self.orders[d].append(o)
                        self.trade_source[d] = 'T'
                        self.log(f"[{d._name}] [TREND MODE] T-Strategy Sell Limit @ {limit_price:.2f}")

                # --- 场景 2: 宽幅震荡 (派 B 部队) ---
                elif regime == 'VOLATILE':
                    # 下轨 + 超卖
                    if d.close[0] < self.inds[d]['bb'].bot[0] and self.inds[d]['rsi'][0] < self.p.b_rsi_buy:
                        # 震荡市不能无脑接飞刀，这里只挂深坑单，不打市价单，非常保守
                        bandwidth = self.inds[d]['bb'].top[0] - self.inds[d]['bb'].bot[0]
                        deep_price = self.inds[d]['bb'].bot[0] - (bandwidth * self.p.b_limit_buffer)

                        # 只有当均线没有大幅下跌时才接（防暴跌）
                        if d.close[0] > self.inds[d]['sma_s'][0] * 0.95:
                            o = self.buy(data=d, size=base_size, price=deep_price, exectype=bt.Order.Limit, valid=2)
                            self.orders[d].append(o)
                            self.trade_source[d] = 'B'
                            self.log(f"[{d._name}] [VOLATILE MODE] B-Strategy Deep Limit @ {deep_price:.2f}")

                    # 上轨 + 超买
                    elif d.close[0] > self.inds[d]['bb'].top[0] and self.inds[d]['rsi'][0] > self.p.b_rsi_sell:
                        bandwidth = self.inds[d]['bb'].top[0] - self.inds[d]['bb'].bot[0]
                        deep_price = self.inds[d]['bb'].top[0] + (bandwidth * self.p.b_limit_buffer)

                        if d.close[0] < self.inds[d]['sma_s'][0] * 1.05:
                            o = self.sell(data=d, size=base_size, price=deep_price, exectype=bt.Order.Limit, valid=2)
                            self.orders[d].append(o)
                            self.trade_source[d] = 'B'
                            self.log(f"[{d._name}] [VOLATILE MODE] B-Strategy Deep Limit @ {deep_price:.2f}")

                # --- 场景 3: 挤压/突破 (派 M 部队) ---
                elif regime == 'SQUEEZE':
                    # MACD 金叉试图捕捉突破
                    if self.inds[d]['m_cross'][0] > 0:
                        # 突破要果断，市价入场
                        o1 = self.buy(data=d, size=base_size, exectype=bt.Order.Market)
                        self.orders[d].append(o1)
                        # 突破后常有回踩，挂单加仓
                        limit_deep = d.close[0] - (self.inds[d]['atr'][0] * self.p.m_atr_mult)
                        o2 = self.buy(data=d, size=base_size // 2, price=limit_deep, exectype=bt.Order.Limit, valid=1)
                        self.orders[d].append(o2)

                        self.trade_source[d] = 'M'
                        self.log(f"[{d._name}] [SQUEEZE MODE] M-Strategy Breakout! Market + Limit")

                    elif self.inds[d]['m_cross'][0] < 0:
                        o1 = self.sell(data=d, size=base_size, exectype=bt.Order.Market)
                        self.orders[d].append(o1)
                        limit_deep = d.close[0] + (self.inds[d]['atr'][0] * self.p.m_atr_mult)
                        o2 = self.sell(data=d, size=base_size // 2, price=limit_deep, exectype=bt.Order.Limit, valid=1)
                        self.orders[d].append(o2)

                        self.trade_source[d] = 'M'
                        self.log(f"[{d._name}] [SQUEEZE MODE] M-Strategy Breakout! Market + Limit")

            # --- 持仓状态：B策略特有的离场逻辑 ---
            else:
                # 只有震荡单(B)需要回归中轨平仓
                # T和M单子享受趋势红利，直到移动止损被触发
                if self.trade_source[d] == 'B':
                    mid = self.inds[d]['bb'].mid[0]
                    if (pos.size > 0 and d.close[0] >= mid) or (pos.size < 0 and d.close[0] <= mid):
                        self.close(data=d)
                        self.log(f"[{d._name}] B-Strategy Target Reached (Mean Reversion)")

    def notify_order(self, order):
        d = order.data
        if order.status in [order.Submitted, order.Accepted]:
            return

        if order in self.orders[d]:
            self.orders[d].remove(order)

        if order.status in [order.Completed]:
            side = "BUY" if order.isbuy() else "SELL"
            self.log(f"[{d._name}] {side} EXEC @ {order.executed.price:.2f} size={order.executed.size}")

            if self.getposition(d).size != 0:
                if side == "BUY":
                    self.inds[d]['highest'] = max(self.inds[d]['highest'] or 0, d.close[0])
                else:
                    self.inds[d]['lowest'] = min(self.inds[d]['lowest'] or 999999, d.close[0])

        elif order.status in [order.Canceled, order.Margin, order.Rejected, order.Expired]:
            pass
